//
// Created by tudom on 2019-05-29.
//


#include <cmath>
#include <iostream>
#include <limits>
#include <boost/math/special_functions/relative_difference.hpp>
#include <boost/math/special_functions/next.hpp>

#include "Utils.hpp"

#define CQT_USE_BOOST_MATH ${CQT_BOOST_MATH_FOUND}

namespace LibStarch::Utils {
#if CQT_USE_BOOST_MATH == 1
  using boost::math::epsilon_difference;
  using boost::math::float_distance;
#endif
  namespace Impl {

    union ParamValue_ {
        long numeric;
        std::vector<std::string> vectorial;
    };

    struct ASTSubParams_ {
        bool advanced;
        ParamValue_ val;
    };

    ASTTypeCtor_::~ASTTypeCtor_() {
        delete val;
    }
  }

  template<class _1, class _2>
  bool Impl::VoidExpr_<_1, _2>::eval() const { return false; }

  template<class L, class R>
  Impl::VoidExpr_<L, R>::operator bool() { return false; }

  template<class L, class R>
  Impl::VoidExpr_<L, R>::operator int() { return 0; }


  bool deq(double a, double b) {
#if CQT_USE_BOOST_MATH == 1
      return !(float_distance(a, b) || epsilon_difference(a, b));
#else
      return std::fabs(a - b) <= std::numeric_limits<double>::epsilon();
#endif
  }

  bool dne(double a, double b) {
      return !deq(a, b);
  }

  bool dgt(double a, double b) {
      return b - a < 0.0;
  }

  bool dlt(double a, double b) {
      return a - b < 0.0;
  }

  bool dge(double a, double b) {
      return !dlt(a, b);
  }

  bool dle(double a, double b) {
      return !dgt(a, b);
  }
}

std::string std::to_string(LibStarch::Utils::Type type) {
    using namespace LibStarch::Utils;
    switch (type) {
        case Impl::typeTrueScalar:return "TrueScalar";
        case Impl::typeCharScalar:return "CharacterScalar";
        case Impl::typeFlatArray:return "FlatArray";
        case Impl::typeCompArray:return "ComplexArray";
        case Impl::typeHashMap:return "HashMap";
        case Impl::typeTreeMap:return "TreeMap";
        case Impl::typeReference:return "Reference";
        case Impl::typeFunction:return "Function";
    }
    return "";
}

std::string std::to_string(LibStarch::Utils::Instruction type) {
    using namespace LibStarch::Utils;
    switch (type) {
        case Impl::instPlus:return "Plus";
        case Impl::instMinus:return "Minus";
        case Impl::instStepForward:return "StepForward";
        case Impl::instStepBackward:return "StepBackward";
        case Impl::instStepInto:return "StepInto";
        case Impl::instStepOut:return "StepOut";
        case Impl::instPrint:return "Print";
        case Impl::instRead:return "Read";
    }
    return "";
}

std::string std::to_string(LibStarch::AdditionExpression& expr) {
    return "AdditionExpression";
}

std::string std::to_string(LibStarch::SubtractionExpression& expr) {
    return "SubtractionExpression";
}

std::string std::to_string(LibStarch::MultiplicationExpression& expr) {
    return "MultiplicationExpression";
}

std::string std::to_string(LibStarch::DivisionExpression& expr) {
    return "DivisionExpression";
}

std::string std::to_string(LibStarch::ModuloExpression& expr) {
    return "ModuloExpression";
}

std::string std::to_string(LibStarch::ValueExpression& expr) {
    return "ValueExpression";
}

std::string std::to_string(LibStarch::NegateExpression& expr) {
    return "NegateExpression";
}

std::string std::to_string(LibStarch::TernaryExpression& expr) {
    return "TernaryExpression";
}

std::string std::to_string(LibStarch::EqualityExpression& expr) {
    return "EqualityExpression";
}

std::string std::to_string(LibStarch::InequalityExpression& expr) {
    return "InequalityExpression";
}

std::string std::to_string(LibStarch::GreaterThanExpression& expr) {
    return "GreaterThanExpression";
}

std::string std::to_string(LibStarch::GreaterOrEqualExpression& expr) {
    return "GreaterOrEqualExpression";
}

std::string std::to_string(LibStarch::LessThanExpression& expr) {
    return "LessThanExpression";
}

std::string std::to_string(LibStarch::LessOrEqualExpression& expr) {
    return "LessOrEqualExpression";
}

std::string std::to_string(LibStarch::ValExpr& val) {
    return "ValExpr";
}

std::string std::to_string(LibStarch::ValText& val) {
    return "ValText";
}

std::string std::to_string(LibStarch::ValNumber& val) {
    return "ValNumber";
}

std::string std::to_string(LibStarch::ValID& val) {
    return "ValID";
}
